#consult 

## Структура
### background.ts
скрипт, который выполняется nodejs. В нем выполняются все нодовские модули и они будут работать.
бОльшая часть автоматически сгенерирована
базовые настройки электрон в 
поменял размеры окна (ширина и высота)
BrowserWindow - основное окно

![[Pasted image 20201106044556.png]]
прикрутил, по событию fetchSubs отправляет полученные субтитры в окно через ipc #interaction

fetchsubs генерируется в окне Home.vue ![[Pasted image 20201106045036.png]]

перехват событий электрона
![[Pasted image 20201106045549.png]]

### main.ts
файл обрабатывается браузерным окном (электрона
сюда мы уже не можем подключать библиотеки, которые использ нативные зависимости вроде модулей на c++, библ взаимод с файл системой и т п); чтобы понять что не могу - если не напугает что брьаузер может это делать, можно использовать...
импортируем бутстрап css (готовые стили)

создаем главный инстансы в createApp

### subsParser.ts
использует ytdl библиотеку для получения субтитров с ютуб видео

### app.vue
стили скопировал из его верстки
единственно что делает - копирует router-view
аналог с реактом где разные роуты в окне авторизвации и т  д
#learn router vue cli
router-view - тоже компонент. смотрит на урл в адресной строке и в зависимсоти от этого отрисовывает другие компоененты
но у нас пока только один путь Home ![[Pasted image 20201106050046.png]]

зачем роутер. если есть панель настроек, которой мы полностью хотим заменить содержимое нашего окна
но если отдельное окно - это уже не про роутер
в скайпе разные диалоги с разными людьми

### home.vue
вся визуальная структура

[[export default]] - метод setup - #learn vue js composition api https://composition-api.vuejs.org/  (тут на 7ми минутном видео хорошо объясняется про setup; он дает возможность не делить по разным блокам сущности, связанные к окнертным функционалом; ), по идее логика такая - 
, оно лучше поддерж тайпскриптом и позволяет более эффективно переиспользовать код

#### template
использует бутстрап (набор стилей - container-fluid, стилизация текстариа)
v-model возле текстариа  - привязывает реактивную переменную к текстариа (если в нее вносятся изменения, они отражаются сразу в textarea)
![[Pasted image 20201106050619.png]]
![[Pasted image 20201106050915.png]]
[[v-model]]

@click привязка к событию ![[Pasted image 20201106050745.png]] ![[Pasted image 20201106050824.png]]

ANALYSIS
https://vuejs.org/v2/guide/list.html
v-for ![[Pasted image 20201106051023.png]]

![[Pasted image 20201107091918.png]]

![[Pasted image 20201106051130.png]] ? [[v-model]]

вот тут в ref мы уже записываем хтмл тег webview ![[Pasted image 20201106051712.png]] , а к чему мы привыязываемся, если реф пустой? к значению тега?

сделали вместе правку, чтобы очищалась ![[Pasted image 20201106051202.png]]

#question как настроить eslint?
#todo

в webview по умолч выполняются скрипт с ютуба
![[Pasted image 20201106051811.png]] 
inject path
![[Pasted image 20201106051821.png]]
![[Pasted image 20201106051841.png]]
скрипт не проходит через этапы компиляции. он скармл ютуб окну, чтобы он выполнился
этот скрипт который позволяет контролироваь ютуб как таковой
интересно как ipcrenderer здесь привязывается к событиям и отправляет их ![[Pasted image 20201106052013.png]]
просто send от ipcrenderr отправляет событие нодовскому процессу , а сендтохост отправляет владельцу вебвью. Событие 'time' всплывает на вебвью, там мы его и ловим. событие time мы обрабатываем и меняем выбор в таблице ![[Pasted image 20201106052249.png]]
onMounted(https://youtu.be/b6Ac0jcqJIg?t=2316 https://ru.vuejs.org/v2/guide/instance.html#%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D0%B0-Vue ) -  когда вебвью отрендерился мы ему добавляем обработчики событий #question если на странице несколько вебвью, мы посылаем несколько раз onmounted?

did-navigate - отслеживаем переходы между видео ![[Pasted image 20201106052517.png]] 
#question это стандартный обработчик?

### store index.ts

setCurrentTime используем через store. как был для реакта Redux, как юзали эффектор, тут можно польоваться базовыми реактивными сущностями Vue за пределами компонента. Позволяет шарить состояние между многими компонентами. Эти данные можно выдергивать из любого куска кода и они будут нам доступны . В качестве рефа - массив сущностей для хранения субтитров (но он не привязан к какому либо контролу) #learn паттерн состояние

и тут деж слушаем subsready. Когда мы отправляем fetchsubs на бекенд (точнее на нодеjs), он что то делает и создает событие subsready, и его мы ловим в сторе. Потому что субтитры хранятся в сторе и мы хотим здесь же обработать это событие и сохранить субтитры
![[Pasted image 20201106085801.png]]


#learn реф подробнее почитать

26 мин

лямбда функцияю с параметрами (для сет)
![[Pasted image 20201106085137.png]]

#learn store pattern state manager, vueex ![[Pasted image 20201106090349.png]] redux, 

мы используем pattern stat manager, чтобы в будущем один центральный компонент не был очень нагруженным и не было сложно ориенитроваться (много ответственности и сложно контролировать). при желанием можно сделать несколько в store. Идея чтобы не перегрузить один компонент.

## Вопросы
Подскажи плз, как эту базовую иконку поменять? https://www.electron.build/icons

как вот здесь "легким движением руки" добавить возможность сохранять БОЛЕЕ 2х субтитров сзади (до текущей позиции). Конечно, при их наличии.
>тут я беру отрезок массива от active - 1 до active + 1. Просто .slice берет первый включительно, а последний исключительно. Тернарники стоят для защиты от выхода за границу массива

![[Pasted image 20201106094647.png]]
Нашел статейку про регистрацию шорткатов. Вопрос - можно ли нам использовать такой же подход? Если да, то где вызывать globalShortcut.register? в background.ts ?
>тут они используют модуль remote, которые не рекомендуется использовать. Если делать точно как у них, то надо делать где-то в браузеном процессе. Но можно сделать это без импорта из remote, и тогда это надо будет делать в background.ts

разница между определениями пустого ref и непустого. Получается, в первом случае мы привязываем к значению элемента, в другом к самому элементу? Но в обохи случаях мы можем обратиться как .value - это меня дезориентирует http://joxi.ru/1A5Q3L8tD8dejA
>все эти рефы не пустые, просто typescript не может автоматически вывести тип для null. Поэтому надо указать его явно

как настроить eslint
>надо скачать расширение, а потом включить доверие к установленной в node_modules версии eslint. Возможно, будет проще сделать на следующем консалте

onMounted события, насколько я тебя услышал происходит - когда вебвью отрендерился и мы ему добавляем обработчики событий #question если на странице несколько вебвью, onmounted приходит несоклько раз?
>onMounted происходит тогда, когда конкретный компонент отрендерился и содержимое его template уже есть на странице

вопрос - а зачем мы пряем subtitles за get и set?
>можно было просто вывести их наружу, но в том месте, где я нашел это, рекомендовали делать через get/set. Я думаю, это связанно с тем, что в оригинальной версии Vuex (который пытались повторить), нельзя напрямую мутировать данные, с целью гарантии корректности

кажи, а почему fetchSubs обрабатывает именно нода?
>потому что так было в реализации не на Vue. Теоретически, можно сделать и средствами браузера

![[Pasted image 20201106095013.png]]
ipcrenderer перелавливает события только от win.webcontents? мне интересно почему именно ему посылается событие (webcontents)
>ну в объекте ipcMain вообще нет методов для отправки событий, так что надо явно указать, кому оно идет

получается в скобочках идет задание значения по умолчанию?

получается в скобочках идет задание значения по умолчанию?
>да

чтобы добавить иконку ![[Pasted image 20201106143127.png]] https://www.electron.build/icons


30 минута

#question activeElement.value - разобратсья почему там индекс и с тернарниками

доработка добавление сохранения url : сначал собрать , потом сохранить, потом подгрузить. собрать проще через фронтенд. урл мы получаем в fetchsubtitles ![[Pasted image 20201106143606.png]] . можно его попутно где то сохранить  и держать как кусок состояния. Например отправить в стор (сами данные + геттер и сетртер)
![[Pasted image 20201106143714.png]]
computed потому что она позволяет в темплейте пользоваться этой штукой без скобок. это чисто синтакс сахар
 и вставляем ![[Pasted image 20201106143949.png]]
 
 по хорошему currentulr и filtertext вынести в стор и оттуда контролироватть ![[Pasted image 20201106144034.png]]
 
 из нодовсокго приложения у нас нет инфы, которую мы собрали на фронтенде. Стор он тоже хранится на фронетде ![[Pasted image 20201106144152.png]] . было бы полезно но у нас нет нужно ифны, которую мы готовы сохранить . поэтому пишем в стор
 ![[Pasted image 20201106144252.png]]
 отсюда мы в файловую систему писать не можем!!!, поэтому нам надо отправить событие в background.ts
 теперь на надо это событие поймать в background.ts (в нодовский процесс). Ипользуем ipcRenderer.send("saveState") и первым аргументом отправилм urlSaved.Value
 
 теперь нам надо его поймать в background.ts.
 ipcMain.on('saveState'б (e,url)=?{}) //лямбда обработчик всегда первым агрумомм принимает соыбтие
  и метод делает асинк, это повзолит promise использовать
  #question механика использования промисных штук, как бы работало, если бы перед лямбдой не было асинк

import fs, path
 
 ![[Pasted image 20201106144454.png]]
 
 ![[Pasted image 20201106144509.png]]
 вот так в итоге
 42 минута
 
 получение папки appdata
 Олег Белохохлов, [05.11.20 17:44]
app.getPath('userData')

Олег Белохохлов, [05.11.20 18:04]
JSON.stringify({КАКОЙ-ТО ОБЪЕКТ})

Олег Белохохлов, [05.11.20 18:04]
JSON.parse("КАКАЯ-ТО JSON строка")
 #todo
 
 фокус на текстариа при сохранении кусочка
 делаем реф для текстарии, а не на содержимое, в типе HTMLTextareaelement
 ![[Pasted image 20201106194837.png]]
 и его надо передать вниз (через объект, в котором возвращается много разной дичи)
 тут в отличии htmltablerowelement потому что много всяких элементов  (чтобы Vue знал, какие объекты у нас есть) ![[Pasted image 20201106195001.png]] , поэтому квадратные скобки, то есть какой то пустой массив передаем
 добавили сюда (в ретерн) текстариаэлемент ![[Pasted image 20201106195141.png]]
 далее переходим в template, находим текстарию и прописываем, что  <textarea id="txtCurrentSub" class="w-100 p-2" v-model="textAreaContent"
              placeholder="Press copy current button to paste current sub title here..."
              ref="textAreaElement"></textarea>
 в отличие от привязки значения, которое через v-model
 
добавление фокусировки
 const saveCurrentPiece = () => {
      textAreaContent.value += `${getSubTitles.value
        .slice(
          getActiveElement.value - 1 >= 0 ? getActiveElement.value - 1 : 0,
          getActiveElement.value + 2 < getSubTitles.value.length
            ? getActiveElement.value + 2 : getSubTitles.value.length,
        ).map((e) => e.Text).join('\n')}\n--------\n`;

      if (textAreaElement.value == null) return;

      textAreaElement.value.focus();
    };
	
yarn lint --fix, чобы исправить косяки

Ctrl+R при serve перезагрузить в окне